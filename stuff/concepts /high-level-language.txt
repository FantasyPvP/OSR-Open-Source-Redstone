# high level language planning / documentation

here goes i guess, this is going to be the hardest part of this entire project but it will be necessary in order to be able to program effectively for the environment


CY++ high level programming language specs / programming style:

    - object and class oriented,
        - each class will be compiled separately into a separate assembly code file, then they will be combined together into a working program / executable.
        - a class will consist of several functions including a function labelled "Default" which when compiled into assembly will be placed at the top to execute first
          in the program.
        - one class must be labelled "main" and this class will be put in a file called main.txt and will always execute first on the vm based architecture
        - all of the other classes will be compiled into the same directory, with the name of the class that it contains.
        - when this is compiled to binary, we could either have a dynamic memory allocator on the system that will make the variable locations for each running class relative
          or we could make it so that all of the class files when compiled to binary are put into one file. this would make the most sense as it would eliminate the need 
          for custom hardware and extra assembly commands / processes just to allocate memory for each class when we can unify the program at a later stage.
        - separating into classes means that we can have a separate abstract syntax tree for each class / function, this simplifys things since we are dealing with less
          complex logic / algorithms, essentially decomposing the problem into multiple diffrent low level programs that are all compiled together into binary

    - static variable declaration
        - to keep memory management simple for the computer to handle (remember we are dealing with an architecture that could run on a redstone comuter, many of which
          run at well under 1Hz, with 1Hz being an impressive achievement even for efficient hardware)
        - it means that we have to declare the type of the variable before we assign anything to it. this makes memory management easier like ive previously stated but
          can result in some inconvenience for users that are more used to more dynamic languages like python



the language / syntax:

    - calling variables / functions
        - examples of all syntax explained here will be given under this section
        - an in-built function will be called with the "$" symbol
        - a user defined function will be defined and called with "@" in reference to the function so the compiler can find the functions and link their memory locations.

        



examples: 
(for each program assume that the first line is the first line in the file / the first location in ROM)

    - hello world

        $output(STR "hello world")

        - "$output" is the inbuilt method for outputting to console
        - the string "hello there" is declared using the "STR" keyword to its left
        - the brackets that are to the right of the output function contain everything that is to be outputted

        - assembly equivalent:

        VAR [STR "hello world" -> 01]
        LDA [01 -> REG-1]
        OUT [REG-1]
        END []




    - basic program with a class:

        class main():
            function @default():
                INT x = 1 + 1
                $output(x)
                &return()

        - the class is declared with the class variable like it would be in python
        - function is declared by the function keyword on an indented line inside the class
        - everything inside the function is further indented to show its contents
        - the INT keyword is used to show the variable type of "x"
        - "&return" is used to exit the function
        - basic mathematical operations like + and - can be used natively, however more complex operations like division
          and multiplication must be done using inbuilt modules




        - assembly equivalent:
        (all code stored in main.txt)


        #main.default:
        VAR [0 -> 01] #x
        INT [1 -> 02] 
        INT [1 -> 03]
        LDA [02 -> REG-1]
        LDA [03 -> REG-2]
        ADD [REG-1 + REG-2]
        OUP [ALU]
        END []


    - basic program that takes an input, stores an integer, and outputs "hello world" that number of times

      class main():

          function @default():
              INT num = $input("enter an integer")
              loop i, if i < num, i += 1:
                  $output(STR "hello world")
              &return()


      - all of the logic for this program is stored in the "main" class in the "default" function
      - it declares an integer with the identifier "num"
      - it assigns an input to the integer "num"
      - the loop keyword loops everything inside it "num" times
      - inside the loop there is an output statement that outputs "hello world"
      - it then returns nothing from the function

      assembly implementation:
      (main.txt)


 